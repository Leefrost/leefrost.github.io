[{"categories":["Архітектура"],"content":"Коротко про CDN","date":"2022-09-16","objectID":"/ua/content-delivery-network/","tags":["system-design"],"title":"Мережа доставки (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Мережа доставки (і розповсюдження) контенту (CDN) — це територіально розподілена група серверів, які працюють разом, щоб забезпечити швидку доставку Інтернет-вмісту. Як правило, статичні файли, такі як HTML/CSS/JS, фотографії та відео, розповсюджуються саме з CDN. ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:0:0","tags":["system-design"],"title":"Мережа доставки (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Як це працює? У CDN вихідний сервер містить оригінальні версії вмісту, тоді як периферійних серверів багато і вони розподілені в різних місцях по всьому світу. Щоб мінімізувати відстань між відвідувачами та сервером веб-сайту, CDN зберігає кешовану версію свого вмісту в кількох географічних локаціях, відомих як периферійні сервери. Кожна переферійна локація містить кілька серверів кешування, відповідальних за доставку вмісту відвідувачам у безпосередній близькості від нього. Після того, як статичні активи будуть кешовані на всіх серверах CDN для певного розташування, усі наступні запити відвідувачів веб-сайту на статичні активи будуть доставлені з цих периферійних серверів замість джерела, таким чином зменшуючи навантаження на джерело та покращуючи масштабованість. Наприклад, коли хтось у Великій Британії надсилає запит на наш веб-сайт, який може бути розміщений у США, він обслуговуватиметься з найближчої локації, наприклад, із Лондона. Це набагато швидше, ніж коли відвідувач робить повний запит на вихідний сервер, що збільшує затримку. ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:1:0","tags":["system-design"],"title":"Мережа доставки (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Типи CDN Загалом CDN ділиться на 2 підвиди: ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:2:0","tags":["system-design"],"title":"Мережа доставки (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Push CDNs Push CDN отримують новий вміст щоразу, коли відбуваються зміни на сервері. Ми беремо повну відповідальність за надання вмісту, завантаження безпосередньо в CDN і зміну URL-адреси, щоб вони вказували на CDN. Ми можемо налаштувати термін дії вмісту та його оновлення. Вміст завантажується лише тоді, коли він новий або змінений, мінімізуючи трафік, але максимізуючи пам’ять. Сайти з невеликим обсягом трафіку або сайти з вмістом, який не часто оновлюється, добре працюють із push CDN. Вміст розміщується на CDN один раз, замість того, щоб повторно витягуватися через регулярні проміжки часу. ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:2:1","tags":["system-design"],"title":"Мережа доставки (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Pull CDNs У ситуації Pull CDN кеш оновлюється на основі запиту. Коли клієнт надсилає запит, який вимагає отримання статичних ресурсів із CDN, якщо CDN їх не має, він отримує нещодавно оновлені ресурси з початкового сервера та заповнює свій кеш цим новим ресурсом, а потім надсилає це новий кешований ресурс для користувача. На відміну від Push CDN, це вимагає менше обслуговування, оскільки оновлення кешу на вузлах CDN виконуються на основі запитів від клієнта до початкового сервера. Сайти з інтенсивним трафіком добре працюють із CDN за запитом, оскільки трафік розподіляється більш рівномірно, а на CDN залишається лише нещодавно запитуваний вміст. ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:2:2","tags":["system-design"],"title":"Мережа доставки (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Недоліки Як ми всі знаємо, хороші речі пов’язані з додатковими витратами, тому давайте обговоримо деякі недоліки CDN: Додаткова плата: використання CDN може бути дорогим, особливо для послуг із високим трафіком. Обмеження: деякі організації та країни заблокували домени або IP-адреси популярних CDN. Розташування: якщо більша частина нашої аудиторії знаходиться в країні, де CDN не має серверів, дані на нашому веб-сайті можуть переміщатися далі, ніж без CDN. ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:3:0","tags":["system-design"],"title":"Мережа доставки (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Приклади Найбільш відомі провайдери CDN: Amazon CloudFront Google Cloud CDN Cloudflare CDN Fastly ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:4:0","tags":["system-design"],"title":"Мережа доставки (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Розгортання"],"content":"Корисні поради для роботи з Docker","date":"2023-03-12","objectID":"/ua/docker-best-practice/","tags":["докер","контейнеризація"],"title":"7 практик щоб працювати з Docker на повну","uri":"/ua/docker-best-practice/"},{"categories":["Розгортання"],"content":"Програмування - це завжди шлях еволюції. Власне еволюція сучасних рішень розробки (мов, оточення, тощо) принесла чимало нових підходів та вимог - важко уявити сучасне програмування без високорівневих фреймворків, контейнерів, хмарного обчислення чи спеціальних дата сховищ. Хочу поділитись кількома практичними порадами саме для роботи з контейнерами та контейнеризацією, зокрема щодо Docker та його контейнерів. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:0:0","tags":["докер","контейнеризація"],"title":"7 практик щоб працювати з Docker на повну","uri":"/ua/docker-best-practice/"},{"categories":["Розгортання"],"content":"7 корисних практик при роботі з Docker контейнерами Kubernetes Engine — це чудове місце для запуску ваших робочих процесів у масштабі. Але перш ніж використовувати Kubernetes, вам потрібно контейнеризувати свої програми. Ви можете запускати більшість програм у контейнері Docker без зайвих клопотів. Однак ефективне використання цих контейнерів на практиці та оптимізація процесу збирання контейнеру — це уже зовсім інші речі. Слід звернути увагу на ряд особливостей, які зроблять ваші команди розробників і тестувальників щасливими. Ця публікація містить поради та найкращі практики, які допоможуть вам ефективно створювати контейнери. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:0","tags":["докер","контейнеризація"],"title":"7 практик щоб працювати з Docker на повну","uri":"/ua/docker-best-practice/"},{"categories":["Розгортання"],"content":"1. Один контейнер - одна програма Контейнер працює найкраще, коли в ньому працює лише одна програма. Ця програма повинна мати єдиний батьківський процес - завершення якого приведе до зупинки контейнера. Це дуже корисно. Не запускайте PHP і MySQL в одному контейнері: це важче налагоджувати, сигнали Linux не оброблятимуться належним чином, ви не можете горизонтально масштабувати контейнери PHP тощо. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:1","tags":["докер","контейнеризація"],"title":"7 практик щоб працювати з Docker на повну","uri":"/ua/docker-best-practice/"},{"categories":["Розгортання"],"content":"2. Правильно обробляйте PID 1, сигнали та зомбі процеси Kubernetes і Docker надсилають сигнали Linux вашій програмі всередині контейнера, щоб зупинити її. Вони надсилають ці сигнали процесу з ідентифікатором (PID) 1. Якщо ви хочете, щоб ваша програма зупинялася правильно і коли це необхідно, вам потрібно правильно обробляти вхідні сигнали. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:2","tags":["докер","контейнеризація"],"title":"7 практик щоб працювати з Docker на повну","uri":"/ua/docker-best-practice/"},{"categories":["Розгортання"],"content":"3. Використовуйте правильно кеш збірки у Docker Docker може кешувати рівні ваших збірок, щоб прискорити повторні збірки. Це дуже корисна функція, але вона має певні особливості поведінки, які потрібно враховувати під час написання файлів Docker. Наприклад, ви повинні додати код вашої програми якомога пізніше у Dockerfile, щоб базова збірка та залежності вашої програми кешувалися й не перебудовувалися під час кожної збірки. Наприклад: FROM python:3.5 COPY my_code src RUN pip install my_requirements Вам варто змінити наступні стрічки коду: FROM python:3.5 RUN pip install my_requirements COPY my_code src У новій версії результати роботи команди pip будуть закешовані для подальших збірок. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:3","tags":["докер","контейнеризація"],"title":"7 практик щоб працювати з Docker на повну","uri":"/ua/docker-best-practice/"},{"categories":["Розгортання"],"content":"4. Видаляйте непотрібні залежності Зменшення поверхні для атак вашої хост-системи завжди є хорошою ідеєю, і це набагато легше зробити з контейнерами, ніж із традиційними системами. Видаліть усе, що програмі не потрібно зі свого контейнера. Або, ще краще, додайте лише свою програму до збірки без дистрибутива або іншої початкової збірки. Ви також повинні, якщо можливо, зробити файлову систему контейнера доступною лише для читання. Це забезпечить Вам найкращу безпеку разом з продуктивністю вашої програми ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:4","tags":["докер","контейнеризація"],"title":"7 практик щоб працювати з Docker на повну","uri":"/ua/docker-best-practice/"},{"categories":["Розгортання"],"content":"5. Проектуйте та створюйте наймешн можливу збірку Хто любить завантажувати сотні мегабайт непотрібних даних? Завжди тримайте одним з найкращих показників - розмір збірки - на максимально низькому рівні. Це зменшує час завантаження, час холодного запуску та використання диска. Ви можете використати кілька стратегій, щоб досягти цього: почати з мінімальної базової збірки, використати загальні рівні між збірками та не забувайте про багатоетапну збірку у Docker. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:5","tags":["докер","контейнеризація"],"title":"7 практик щоб працювати з Docker на повну","uri":"/ua/docker-best-practice/"},{"categories":["Розгортання"],"content":"6. Правильно позначайте свої збірки Теги – це те, як користувачі вибирають, яку версію вашої збірки вони хочуть використовувати. Існує два основних способи позначення тегами: семантичне керування версіями або використання хешу фіксації Git вашої програми. Незалежно від того, який ви виберете, документуйте це та чітко визначте очікування, які мають мати користувачі зібрки. Будьте обережні: хоча користувачі очікують, що деякі теги, як-от тег “latest”, будуть мігрувати з однієї збірки на іншу, а також, що інші теги будуть залишатись незмінними, навіть якщо технічно це не так. Наприклад, після того, як ви позначили певну версію своєї збірки тегом «1.2.3», ви ніколи не повинні переміщувати цей тег на інші збірки. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:6","tags":["докер","контейнеризація"],"title":"7 практик щоб працювати з Docker на повну","uri":"/ua/docker-best-practice/"},{"categories":["Розгортання"],"content":"7. Уважно подумайте, чи варто використовувати публічні збірки Використання загальнодоступних збірок може бути чудовим способом почати роботу з певним програмним забезпеченням. Однак їх використання у під час релізу чи тестування може спричинити ряд проблем, особливо в середовищі з високими обмеженнями. Можливо, вам знадобиться контролювати те, що в них знаходиться, або ви можете не залежати від зовнішнього сховища, наприклад. З іншого боку, створення власних збірок для кожної частини програмного забезпечення, яке ви використовуєте, не є тривіальним, особливо тому, що вам потрібно йти в ногу з оновленнями безпеки попереднього програмного забезпечення. Ретельно зважте плюси та мінуси кожного для конкретного випадку використання та прийміть свідоме рішення. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:7","tags":["докер","контейнеризація"],"title":"7 практик щоб працювати з Docker на повну","uri":"/ua/docker-best-practice/"},{"categories":["Розробка"],"content":"Кешування відповідей для HttpClient","date":"2023-03-12","objectID":"/ua/httpclient-cache-response/","tags":["dotnet","csharp"],"title":"Кешування та HttpClient","uri":"/ua/httpclient-cache-response/"},{"categories":["Розробка"],"content":"Працюючи з системами з високим навантаженням, де час на відповідь дуже обмежений - кеш це перше що приходить на думку. Я розробив невелику бібліотеку для кешування і відтворення відповідей для HttpClient - досить проста та надійна, з підтримкою тонкої конфігурації та налаштуванням кешування за кодом відповіді. ","date":"2023-03-12","objectID":"/ua/httpclient-cache-response/:0:0","tags":["dotnet","csharp"],"title":"Кешування та HttpClient","uri":"/ua/httpclient-cache-response/"},{"categories":["Розробка"],"content":"HttpClient.Cache Проста, in-memory, кеш-обгортка для HttpClient. ","date":"2023-03-12","objectID":"/ua/httpclient-cache-response/:1:0","tags":["dotnet","csharp"],"title":"Кешування та HttpClient","uri":"/ua/httpclient-cache-response/"},{"categories":["Розробка"],"content":"Встановлення dotnet add package Leefrost.HttpClient.Cache ","date":"2023-03-12","objectID":"/ua/httpclient-cache-response/:1:1","tags":["dotnet","csharp"],"title":"Кешування та HttpClient","uri":"/ua/httpclient-cache-response/"},{"categories":["Розробка"],"content":"Плани та ідеї: in-memory підтримка підтримка розподіленого кешування ","date":"2023-03-12","objectID":"/ua/httpclient-cache-response/:1:2","tags":["dotnet","csharp"],"title":"Кешування та HttpClient","uri":"/ua/httpclient-cache-response/"},{"categories":["Розробка"],"content":"Використання Код нижче кешує топ 3 найчастіших відповідей (OK, BadRequest, та InternalServerError) на різний час - 60/10/5 секунд відповідно. HttpClient робить 5 запитів до https://randomuser.me/api/ та зберігає відповіді у кеш на відведений час. Кеш відрепортує 1 промах (початковий, адже у кеші нічого немає) і 4 попадання (тому час відповіді дорівнює 0) const string url = \"https://randomuser.me/api/\"; //Налаштування кешу var cacheExpiration = new Dictionary\u003cHttpStatusCode, TimeSpan\u003e { {HttpStatusCode.OK, TimeSpan.FromSeconds(60)}, {HttpStatusCode.BadRequest, TimeSpan.FromSeconds(10)}, {HttpStatusCode.InternalServerError, TimeSpan.FromSeconds(5)} }; //Відпрацювання запитів var requestHandler = new HttpClientHandler(); var cacheHandler = new InMemoryCacheHandler(requestHandler, cacheExpiration); using (var httpClient = new HttpClient(cacheHandler)) { for (int i = 1; i \u003c= 5; ++i) { Console.Write($\"Attempt {i}: {url}\"); var stopwatch = Stopwatch.StartNew(); var result = await httpClient.GetAsync(url); Console.Write($\" --\u003e {result.StatusCode} \"); stopwatch.Stop(); Console.WriteLine($\"Done in: {stopwatch.ElapsedMilliseconds} ms\"); await Task.Delay(TimeSpan.FromSeconds(1)); } Console.WriteLine(); } //Перевірка статусу var stats = cacheHandler.StatsProvider.GetReport(); Console.WriteLine($\"Cache stats - total requests: {stats.Total.TotalRequests}\"); Console.WriteLine($\"--\u003e Hits: {stats.Total.CacheHit} [{stats.Total.TotalHitsPercent}]\"); Console.WriteLine($\"--\u003e Misses: {stats.Total.CacheMiss} [{stats.Total.TotalMissPercent}]\"); Console.ReadLine(); Ось що ми отримаємо в консолі: Attempt 1: https://randomuser.me/api/ --\u003e OK Done in: 681 ms Attempt 2: https://randomuser.me/api/ --\u003e OK Done in: 75 ms Attempt 3: https://randomuser.me/api/ --\u003e OK Done in: 0 ms Attempt 4: https://randomuser.me/api/ --\u003e OK Done in: 0 ms Attempt 5: https://randomuser.me/api/ --\u003e OK Done in: 0 ms Cache stats - total requests: 5 --\u003e Hits: 4 [0,8] --\u003e Misses: 1 [0,2] ","date":"2023-03-12","objectID":"/ua/httpclient-cache-response/:1:3","tags":["dotnet","csharp"],"title":"Кешування та HttpClient","uri":"/ua/httpclient-cache-response/"},{"categories":null,"content":"Code Story - Автор","date":"2022-09-11","objectID":"/ua/about/","tags":null,"title":"","uri":"/ua/about/"},{"categories":null,"content":" Я на фото 😎 Привіт 👋, я Сергій Ліщук, Leefrost Я чаклую над кодом з 2010 💬 Запитуй мене усе про .NET / JS. 📜 Вивчаю Python і Go. 📓 Пишу тут - Dev.to та тут - CodeStory.me. 🔥 Цікавлюсь ще Machine learning / Data analysis / IOT. 🎙️ Працюю над подкастом про програмування (soon!) 👩‍💻 Мене можна знайти ось тут: Gmail Internet Explorer Twitter Facebook LinkedIn ⚡ Щодня я користуюсь: Visual Studio Visual Studio Code Docker Git .NET TypeScript GraphQL Angular Node.js Microsoft SQL Server Microsoft Azure Amazon AWS 🏅 Тримаю себе у формі ось тут: Codewars HackerRank LeetCode Exercism ","date":"2022-09-11","objectID":"/ua/about/:0:0","tags":null,"title":"","uri":"/ua/about/"}]