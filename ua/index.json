[{"categories":["Архітектура"],"content":"CDN","date":"2022-09-16","objectID":"/ua/content-delivery-network/","tags":["system-design"],"title":"Мережа доправлення (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Мережа доправлення (і розповсюдження) контенту (CDN) — це територіально розподілена група серверів, які працюють разом, щоб забезпечити швидку доставку Інтернет-вмісту. Як правило, статичні файли, такі як HTML/CSS/JS, фотографії та відео, розповсюджуються саме з CDN. ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:0:0","tags":["system-design"],"title":"Мережа доправлення (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Як це працює? У CDN вихідний сервер містить оригінальні версії вмісту, тоді як периферійних серверів багато і вони розподілені в різних місцях по всьому світу. Щоб мінімізувати відстань між відвідувачами та сервером веб-сайту, CDN зберігає кешовану версію свого вмісту в кількох географічних локаціях, відомих як периферійні сервери. Кожна переферійна локація містить кілька серверів кешування, відповідальних за доставку вмісту відвідувачам у безпосередній близькості від нього. Після того, як статичні активи будуть кешовані на всіх серверах CDN для певного розташування, усі наступні запити відвідувачів веб-сайту на статичні активи будуть доставлені з цих периферійних серверів замість джерела, таким чином зменшуючи навантаження на джерело та покращуючи масштабованість. Наприклад, коли хтось у Великій Британії надсилає запит на наш веб-сайт, який може бути розміщений у США, він обслуговуватиметься з найближчої локації, наприклад, із Лондона. Це набагато швидше, ніж коли відвідувач робить повний запит на вихідний сервер, що збільшує затримку. ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:1:0","tags":["system-design"],"title":"Мережа доправлення (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Типи CDN Загалом CDN ділиться на 2 підвиди: ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:2:0","tags":["system-design"],"title":"Мережа доправлення (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Push CDNs Push CDN отримують новий вміст щоразу, коли відбуваються зміни на сервері. Ми беремо повну відповідальність за надання вмісту, завантаження безпосередньо в CDN і зміну URL-адреси, щоб вони вказували на CDN. Ми можемо налаштувати термін дії вмісту та його оновлення. Вміст завантажується лише тоді, коли він новий або змінений, мінімізуючи трафік, але максимізуючи пам’ять. Сайти з невеликим обсягом трафіку або сайти з вмістом, який не часто оновлюється, добре працюють із push CDN. Вміст розміщується на CDN один раз, замість того, щоб повторно витягуватися через регулярні проміжки часу. ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:2:1","tags":["system-design"],"title":"Мережа доправлення (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Pull CDNs У ситуації Pull CDN кеш оновлюється на основі запиту. Коли клієнт надсилає запит, який вимагає отримання статичних ресурсів із CDN, якщо CDN їх не має, він отримує нещодавно оновлені ресурси з початкового сервера та заповнює свій кеш цим новим ресурсом, а потім надсилає це новий кешований ресурс для користувача. На відміну від Push CDN, це вимагає менше обслуговування, оскільки оновлення кешу на вузлах CDN виконуються на основі запитів від клієнта до початкового сервера. Сайти з інтенсивним трафіком добре працюють із CDN за запитом, оскільки трафік розподіляється більш рівномірно, а на CDN залишається лише нещодавно запитуваний вміст. ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:2:2","tags":["system-design"],"title":"Мережа доправлення (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Недоліки Як ми всі знаємо, хороші речі пов’язані з додатковими витратами, тому давайте обговоримо деякі недоліки CDN: Додаткова плата: використання CDN може бути дорогим, особливо для послуг із високим трафіком. Обмеження: деякі організації та країни заблокували домени або IP-адреси популярних CDN. Розташування: якщо більша частина нашої аудиторії знаходиться в країні, де CDN не має серверів, дані на нашому веб-сайті можуть переміщатися далі, ніж без CDN. ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:3:0","tags":["system-design"],"title":"Мережа доправлення (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Архітектура"],"content":"Приклади Найбільш відомі провайдери CDN: Amazon CloudFront Google Cloud CDN Cloudflare CDN Fastly ","date":"2022-09-16","objectID":"/ua/content-delivery-network/:4:0","tags":["system-design"],"title":"Мережа доправлення (і розповсюдження) контенту (CDN)","uri":"/ua/content-delivery-network/"},{"categories":["Deployment"],"content":"Docker and containerization","date":"2023-03-12","objectID":"/ua/docker-best-practice/","tags":["docker","containerization"],"title":"7 практик щоб працювати з Докером на повну","uri":"/ua/docker-best-practice/"},{"categories":["Deployment"],"content":"Development was always a way of evolution. The evolution of modern programming development brings a lot of techniques and requirements - its hard to imagine today’s programming without high-level frameworks, containers, cloud computing or special data storages (even if they are not necessary). Working with some of them, I would like to share small notes about the containerization, especially with Docker containers. Development was always a way of evolution. The evolution of modern programming development brings a lot of techniques and requirements - its hard to imagine today’s programming without high-level frameworks, containers, cloud computing or special data storages (even if they are not necessary). Working with some of them, I would like to share small notes about the containerization, especially with Docker containers. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:0:0","tags":["docker","containerization"],"title":"7 практик щоб працювати з Докером на повну","uri":"/ua/docker-best-practice/"},{"categories":["Deployment"],"content":"7 best practices for building containers Kubernetes Engine is a great place to run your workloads at scale. But before being able to use Kubernetes, you need to containerize your applications. You can run most applications in a Docker container without too much hassle. However, effectively running those containers in production and streamlining the build process is another story. There are a number of things to watch out for that will make your security and operations teams happier. This post provides tips and best practices to help you effectively build containers. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:0","tags":["docker","containerization"],"title":"7 практик щоб працювати з Докером на повну","uri":"/ua/docker-best-practice/"},{"categories":["Deployment"],"content":"1. Package a single application per container A container works best when a single application runs inside it. This application should have a single parent process. For example, do not run PHP and MySQL in the same container: it’s harder to debug, Linux signals will not be properly handled, you can’t horizontally scale the PHP containers, etc. This allows you to tie together the lifecycle of the application to that of the container. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:1","tags":["docker","containerization"],"title":"7 практик щоб працювати з Докером на повну","uri":"/ua/docker-best-practice/"},{"categories":["Deployment"],"content":"2. Properly handle PID 1, signal handling, and zombie processes Kubernetes and Docker send Linux signals to your application inside the container to stop it. They send those signals to the process with the process identifier (PID) 1. If you want your application to stop gracefully when needed, you need to properly handle those signals. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:2","tags":["docker","containerization"],"title":"7 практик щоб працювати з Докером на повну","uri":"/ua/docker-best-practice/"},{"categories":["Deployment"],"content":"3. Optimize for the Docker build cache Docker can cache layers of your images to accelerate later builds. This is a very useful feature, but it introduces some behaviors that you need to take into account when writing your Dockerfiles. For example, you should add the source code of your application as late as possible in your Dockerfile so that the base image and your application’s dependencies get cached and aren’t rebuilt on every build. Take this Dockerfile as example: FROM python:3.5 COPY my_code src RUN pip install my_requirements You should swap the last two lines: FROM python:3.5 RUN pip install my_requirements COPY my_code src In the new version, the result of the pip command will be cached and will not be rerun each time the source code changes. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:3","tags":["docker","containerization"],"title":"7 практик щоб працювати з Докером на повну","uri":"/ua/docker-best-practice/"},{"categories":["Deployment"],"content":"4. Remove unnecessary tools Reducing the attack surface of your host system is always a good idea, and it’s much easier to do with containers than with traditional systems. Remove everything that the application doesn’t need from your container. Or better yet, include just your application in a distroless or scratch image. You should also, if possible, make the filesystem of the container read-only. This should get you some excellent feedback from your security team during your performance review. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:4","tags":["docker","containerization"],"title":"7 практик щоб працювати з Докером на повну","uri":"/ua/docker-best-practice/"},{"categories":["Deployment"],"content":"5. Build the smallest image possible Who likes to download hundreds of megabytes of useless data? Aim to have the smallest images possible. This decreases download times, cold start times, and disk usage. You can use several strategies to achieve that: start with a minimal base image, leverage common layers between images and make use of Docker’s multi-stage build feature. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:5","tags":["docker","containerization"],"title":"7 практик щоб працювати з Докером на повну","uri":"/ua/docker-best-practice/"},{"categories":["Deployment"],"content":"6. Properly tag your images Tags are how the users choose which version of your image they want to use. There are two main ways to tag your images: Semantic Versioning, or using the Git commit hash of your application. Whichever your choose, document it and clearly set the expectations that the users of the image should have. Be careful: while users expect some tags —like the “latest” tag— to move from one image to another, they expect other tags to be immutable, even if they are not technically so. For example, once you have tagged a specific version of your image, with something like “1.2.3”, you should never move this tag. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:6","tags":["docker","containerization"],"title":"7 практик щоб працювати з Докером на повну","uri":"/ua/docker-best-practice/"},{"categories":["Deployment"],"content":"7. Carefully consider whether to use a public image Using public images can be a great way to start working with a particular piece of software. However, using them in production can come with a set of challenges, especially in a high-constraint environment. You might need to control what’s inside them, or you might not want to depend on an external repository, for example. On the other hand, building your own images for every piece of software you use is not trivial, particularly because you need to keep up with the security updates of the upstream software. Carefully weigh the pros and cons of each for your particular use-case, and make a conscious decision. ","date":"2023-03-12","objectID":"/ua/docker-best-practice/:1:7","tags":["docker","containerization"],"title":"7 практик щоб працювати з Докером на повну","uri":"/ua/docker-best-practice/"},{"categories":null,"content":"Про автора","date":"2022-09-11","objectID":"/ua/about/","tags":null,"title":"Автор","uri":"/ua/about/"},{"categories":null,"content":" Сергій Ліщук ","date":"2022-09-11","objectID":"/ua/about/:0:0","tags":null,"title":"Автор","uri":"/ua/about/"},{"categories":null,"content":"Привіт, я Сергій Ліщук, Leefrost 👋 Я займаюсь кодовою магією з 2010 💬 Запитуй мене усе про .NET / JS. 📜 Вивчаю Python і Go. 📓 Пишу тут - Dev.to та тут - CodeStory.me. 🔥 Цікавлюсь ще Machine learning / Data analysis / IOT. 🎙️ Працюю над подкастом про програмування (soon!) Мене можна знайти ось тут: Gmail Internet Explorer Twitter Facebook LinkedIn Щодня я користуюсь: Visual Studio Visual Studio Code Docker Git .NET TypeScript GraphQL Angular Node.js Microsoft SQL Server Microsoft Azure Amazon AWS Трохи змагаюсь тут: Codewars HackerRank LeetCode Exercism ","date":"2022-09-11","objectID":"/ua/about/:0:1","tags":null,"title":"Автор","uri":"/ua/about/"}]